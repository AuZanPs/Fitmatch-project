-- COMPLETE CACHING SYSTEM SETUP FOR FITMATCH
-- Run this entire script in your Supabase SQL Editor
-- Go to: https://app.supabase.com/project/[YOUR-PROJECT-ID]/sql

-- ========================================
-- STEP 1: CREATE THE CACHE TABLE
-- ========================================

-- Create the gemini_cache table
CREATE TABLE IF NOT EXISTS public.gemini_cache (
  id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  user_id UUID REFERENCES auth.users(id) ON DELETE CASCADE,
  request_hash TEXT NOT NULL UNIQUE,
  request_data JSONB NOT NULL,
  gemini_response JSONB NOT NULL,
  created_at TIMESTAMPTZ DEFAULT NOW() NOT NULL,
  last_accessed_at TIMESTAMPTZ DEFAULT NOW() NOT NULL,
  access_count INTEGER DEFAULT 1 NOT NULL
);

-- Add indexes for efficient lookups
CREATE INDEX IF NOT EXISTS idx_gemini_cache_request_hash ON public.gemini_cache(request_hash);
CREATE INDEX IF NOT EXISTS idx_gemini_cache_user_id ON public.gemini_cache(user_id);
CREATE INDEX IF NOT EXISTS idx_gemini_cache_created_at ON public.gemini_cache(created_at);
CREATE INDEX IF NOT EXISTS idx_gemini_cache_last_accessed_at ON public.gemini_cache(last_accessed_at);

-- Enable Row Level Security
ALTER TABLE public.gemini_cache ENABLE ROW LEVEL SECURITY;

-- Drop existing policies if they exist (to avoid conflicts)
DROP POLICY IF EXISTS "Users can view their own cached results" ON public.gemini_cache;
DROP POLICY IF EXISTS "Service role can manage all cache entries" ON public.gemini_cache;

-- Create RLS policies
CREATE POLICY "Users can view their own cached results" ON public.gemini_cache
  FOR SELECT USING (auth.uid() = user_id);

CREATE POLICY "Service role can manage all cache entries" ON public.gemini_cache
  USING (auth.jwt() ->> 'role' = 'service_role');

-- ========================================
-- STEP 2: CREATE CLEANUP FUNCTIONS
-- ========================================

-- Basic cleanup function
CREATE OR REPLACE FUNCTION cleanup_old_cache(age_interval TEXT)
RETURNS INTEGER
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = public
AS $$
DECLARE
  deleted_count INTEGER;
BEGIN
  DELETE FROM public.gemini_cache
  WHERE created_at < NOW() - age_interval::interval;
  
  GET DIAGNOSTICS deleted_count = ROW_COUNT;
  RETURN deleted_count;
END;
$$;

-- Smart cleanup function with size management
CREATE OR REPLACE FUNCTION smart_cache_cleanup(
  max_cache_size_mb INTEGER DEFAULT 100,
  min_age_days INTEGER DEFAULT 7,
  max_age_days INTEGER DEFAULT 30
)
RETURNS INTEGER
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = public
AS $$
DECLARE
  current_size_mb INTEGER;
  deleted_count INTEGER := 0;
  additional_deleted INTEGER := 0;
  target_reduction_mb INTEGER;
  min_age_interval INTERVAL := (min_age_days || ' days')::INTERVAL;
  max_age_interval INTERVAL := (max_age_days || ' days')::INTERVAL;
BEGIN
  -- Get current cache size in MB (rough estimation)
  SELECT COALESCE(SUM(pg_column_size(gemini_response) + pg_column_size(request_data)) / 1024 / 1024, 0)
  INTO current_size_mb
  FROM public.gemini_cache;
  
  -- First pass: Delete all entries older than max_age_days
  DELETE FROM public.gemini_cache
  WHERE created_at < NOW() - max_age_interval;
  
  GET DIAGNOSTICS deleted_count = ROW_COUNT;
  
  -- If we're still over the size limit, do a second pass based on access patterns
  IF current_size_mb > max_cache_size_mb THEN
    target_reduction_mb := current_size_mb - max_cache_size_mb;
    
    -- Delete less frequently accessed entries older than min_age_days
    WITH ranked_cache AS (
      SELECT 
        id,
        (access_count::float / EXTRACT(EPOCH FROM (NOW() - created_at)) * 86400) AS access_score
      FROM public.gemini_cache
      WHERE created_at < NOW() - min_age_interval
      ORDER BY access_score ASC
    )
    DELETE FROM public.gemini_cache
    WHERE id IN (
      SELECT id FROM ranked_cache
      WHERE access_score < 5 -- Don't delete very frequently accessed items
      LIMIT 100 -- Limit deletion batch size
    );
    
    GET DIAGNOSTICS additional_deleted = ROW_COUNT;
    deleted_count := deleted_count + additional_deleted;
  END IF;
  
  RETURN deleted_count;
END;
$$;

-- ========================================
-- STEP 3: CREATE MAINTENANCE LOGS TABLE
-- ========================================

-- Create a maintenance logs table to track cleanup operations
CREATE TABLE IF NOT EXISTS public.maintenance_logs (
  id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  operation VARCHAR(50) NOT NULL,
  details TEXT,
  records_affected INTEGER,
  executed_at TIMESTAMPTZ DEFAULT NOW() NOT NULL
);

-- ========================================
-- STEP 4: VERIFY SETUP
-- ========================================

-- Check if tables were created successfully
SELECT 
  table_name,
  table_type
FROM information_schema.tables 
WHERE table_schema = 'public' 
  AND table_name IN ('gemini_cache', 'maintenance_logs')
ORDER BY table_name;

-- Check if functions were created successfully
SELECT 
  routine_name,
  routine_type
FROM information_schema.routines 
WHERE routine_schema = 'public' 
  AND routine_name IN ('cleanup_old_cache', 'smart_cache_cleanup')
ORDER BY routine_name;

-- ========================================
-- STEP 5: TEST THE FUNCTIONS
-- ========================================

-- Test basic cleanup function
SELECT cleanup_old_cache('1 day');

-- Test smart cleanup function
SELECT smart_cache_cleanup(100, 7, 30);

-- ========================================
-- STEP 6: MANUAL CLEANUP SCHEDULE (if pg_cron not available)
-- ========================================

-- If you don't have pg_cron extension, you can manually run this daily:
-- SELECT smart_cache_cleanup(100, 7, 30);

-- Or weekly:
-- SELECT cleanup_old_cache('21 days');

-- ========================================
-- SUCCESS MESSAGE
-- ========================================

DO $$
BEGIN
  RAISE NOTICE '✅ Caching system setup completed successfully!';
  RAISE NOTICE '📊 Cache table: gemini_cache';
  RAISE NOTICE '🧹 Cleanup functions: cleanup_old_cache, smart_cache_cleanup';
  RAISE NOTICE '📝 Maintenance logs: maintenance_logs';
  RAISE NOTICE '';
  RAISE NOTICE 'Next steps:';
  RAISE NOTICE '1. Deploy your Vercel functions';
  RAISE NOTICE '2. Set up environment variables';
  RAISE NOTICE '3. Test the caching system';
  RAISE NOTICE '4. Set up automated cleanup (see manual-cleanup-solution.md)';
END $$;
